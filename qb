#!/bin/bash

SELF=$0
PREFIX=` echo $0 | sed 's/^.*\///g' `

if [ "--usage" == "$1" ] ; then
    echo "delegates to ${PREFIX}-sub-commands, similar to git"
    exit 2
fi
if [ "--help" == "$1" ] ; then
    echo "QuarterBack: discover commands and encourage documentation"
    echo
    echo "  usage: $PREFIX [sub-commands]"
    echo
    echo "QuarterBack: passes off work to other commands and encourages a"
    echo "self-documenting command structure."
    echo
    echo "Any command of the form in you path of the form ${PREFIX}-foo"
    echo "will be considered a sub-command of ${PREFIX} and executed as"
    echo "'${PREFIX}-foo --usage' which must print one line only and"
    echo "exit with a non-zero exit code."
    echo
    echo "${PREFIX} will use 'compgen -c' (bash tab completion) to discover"
    echo "new commands and allow users to discover and execute them.  It is"
    echo "especially useful for helping to slightly organize every messy"
    echo "internal operational infrastructure."
    echo
    echo "Executing '${PREFIX} foo bar' will execute '${PREFIX}-foo-bar' assuming"
    echo "it exists and is in the path.  If '${PREFIX}-foo' exists, it will be"
    echo "executed first, and in the case of a non-zero exit code, will"
    echo "prevent '${PREFIX}-foo-bar' from executing (like ${PREFIX}-foo && ${PREFIX}-foo-bar)"
    echo ""
    echo "Future extensions could allow '${PREFIX}-foo' to set variables for"
    echo "use in '${PREFIX}-foo-bar'"
    exit 2
fi

# try to delegate for completions
ALL_CMD=${PREFIX}-${PREFIX}-all
hash $ALL_CMD 2> /dev/null
ALL_CMD_EXISTS=$?
if [ "1" == "$ALL_CMD_EXISTS" ] ; then
	echo "error: command $ALL_CMD not found, cannot generate completions"
	exit 1;
fi
# expansions are the first column (full path to executable might be in 2nd column)
FULL_EXPANSIONS=$( $ALL_CMD )
EXPANSIONS=$( echo "$FULL_EXPANSIONS" | awk -- '{print $1}' )

# try to delegate for --usage
USAGE_CMD=${PREFIX}-${PREFIX}-usage
hash $USAGE_CMD 2> /dev/null
USAGE_CMD_EXISTS=$?
if [ "1" == "$USAGE_CMD_EXISTS" ] ; then
	echo "error: command $USAGE_CMD not found, cannot show command descriptions"
	exit 1;
fi

if [ "--all" == "$1" ] ; then
    echo "$EXPANSIONS"
    exit 2
fi

function next_prefixes() {
    PREFIX="$1"
    EXPANSIONS="$2"
    NXT=$( echo "$EXPANSIONS"           \
            | grep ^${PREFIX}-          \
            | sed "s/^${PREFIX}-//g"    \
            | sed 's/-.*//g'            \
            | sort | uniq )
    echo "$NXT"
}

# note, uses $EXPANSIONS instead of compgen
function command_exists() {
    COMMAND="$1"
    echo "$EXPANSIONS" | grep ^$COMMAND$ > /dev/null
    if [ "$?" == "0" ] ; then
        echo 0
    else
        echo 1
    fi
}

# note, uses $EXPANSIONS instead of compgen
function but_wait_theres_more() {
    COMMAND="$1"
    echo "$EXPANSIONS" | grep ^${COMMAND}-.* > /dev/null
    if [ "$?" == "0" ] ; then
        echo 0
    else
        echo 1
    fi
}


# if we're in a chain of commands which cannot ever reach a compgen ($EXPANSIONS)
function lost() {
    COMMAND="$1"
    echo "$EXPANSIONS" | grep ^$COMMAND > /dev/null
    if [ "$?" == "0" ] ; then
        echo 0
    else
        echo 1
    fi
}

function this_node() {
    PREFIX="$1"
    NP=$( next_prefixes "$PREFIX" "$EXPANSIONS" )
    echo "$NP"
}

if [ "$1" == "" ] ; then
    # this is a "branch node", spit out usages
    echo "Commands for ${PREFIX}"
    THIS_NODE=$( this_node ${PREFIX} )
    echo "$THIS_NODE" | while read CMD ; do
        FULL_CMD=$PREFIX-$CMD
        CE=$( command_exists $FULL_CMD )
        if [ "$CE" == "0" ] ; then
            #WHEN="($( date -r $(stat -f "%m" $(which $FULL_CMD)) +%Y-%m-%d ))"
            USAGE="$( $USAGE_CMD $FULL_CMD )"
        else
            #WHEN="(????-??-??)"
            USAGE=" ... "
        fi
        echo " $WHEN $CMD - $USAGE"
    done
    exit 2
fi

function non_terms() {
    NON_TERMINII=$1
    echo $NON_TERMINII
    echo $NON_TERMINII | while read non_term ; do
        $non_term
    done
}

function execute() {
    CMD=$1
    CMD_LINE=$( echo "$FULL_EXPANSIONS" | grep "^$CMD\( \|\$\)" )
    CMD_DISK=$( echo $CMD_LINE | awk -- '{ print $2 }' )
    $CMD_DISK "$@"
}

NON_TERMINII=""
while [ "$1" != "" ] ; do
    SUFFIX=$1
    shift
    PREFIX="${PREFIX}-${SUFFIX}"
    THIS_NODE=$( this_node "$PREFIX" "$EXPANSIONS" )
    WC_THIS_NODE=$( echo "$THIS_NODE" | wc -l | awk -- '{print $1}' )
    TCE=$( command_exists $PREFIX )
    if [[ 1 == $WC_THIS_NODE && 0 == $TCE ]] ; then
        # this is a "terminus node", execute / delegate to this command! (finally!)
        echo $NON_TERMINII | while read ntcmd ; do
            TCENT=$( command_exists $ntcmd )
            if [ 0 == $TCENT ] ; then
                execute $ntcmd
                if [ "0" != "$?" ] ; then
                    echo Error!
                    exit 2
                fi
            fi
        done
        if [ "$?" != "0" ] ; then
             exit 2
        fi
        #echo "ALL_CAPT"
        #echo "$ALL_CAPT"

        #echo source $PREFIX "$@"
        #FOO=888 $PREFIX "$@"
        execute $PREFIX "$@"
        exit $?
    else
        NON_TERMINII="$NON_TERMINII $PREFIX"
    fi
done

if [ "0" != "$?" ] ; then
    exit 2;
fi


# this is a "branch node" (b/c not a terminus), spit out usages
echo "Commands for $PREFIX"
LOST=$( lost $PREFIX )
if [ "0" == "$LOST" ] ; then
    echo "$THIS_NODE" | while read CMD ; do
        FULL_CMD=$PREFIX-$CMD
        CE=$( command_exists $FULL_CMD )
        if [ "$CE" == "0" ] ; then
            #WHEN="($( date -r $(stat -f "%m" $(which $FULL_CMD)) +%Y-%m-%d ))"
            USAGE="$( $USAGE_CMD $FULL_CMD )"
        else
            #WHEN="(????-??-??)"
            USAGE=" ... "
        fi
        echo " $WHEN $CMD - $USAGE"
    done
    exit 2
else
    echo "$PREFIX not found"
fi
