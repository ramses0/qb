#!/usr/bin/env bash

function show_help() {
	echo "Less QQ more Pew-Pew!"
	echo "  --help           prints this message"
	echo "  --help-path      how to add globally available commands to 'qq'"
	echo "  --help-bin       how to format a 'bin' directory so it is linked in to 'qq'"
	echo ""
	echo "'qq' passes off work to other commands and encourages a self-documenting,"
	echo "discoverable, ad-hoc command structure. It is especially useful for helping"
	echo "to slightly organize every messy internal operational infrastructure."
}

function show_help_path() {
	echo "Globally Available Path Commands"
	echo ""
	echo "Any command in your path named 'qq-*' will be executed on every"
	echo "invocation of 'qq'."
	echo ""
	echo "These commands should print out on the first line a useful description"
	echo "followed by 'X' for executable lines and 'D' for description lines"
	echo ""
	echo "Example:"
	echo "   [description of all commands]"
	echo "   X [shortname]      [path_to_exectable]"
	echo "   X [shortname]      [path_to_exectable]"
	echo "   D [sub-shortname]  [description of subcommands]"
	echo "   X [sub-shortname]  [path_to_exectable]"
	echo ""
	echo "$ qq-unix"
	echo "These are standard unix commands"
	echo "X cp /bin/cp"
	echo "X ls /bin/ls"
	echo "D more More commands can be linked here go here"
	echo "X more-ls /bin/ls"
	echo "X more-cp /bin/cp"
	echo ""
	echo "The above commands can be discovered and called as:"
	echo "  $ qq                 # lists all first level commands"
	echo "  $ qq unix            # lists all commands described from qq-unix"
	echo "  $ qq unix cp         # directly execute qq-unix | grep '^X cp '"
	echo "  $ qq unix more ls    # traverse deeper into commands returned by qq-unix"
	exit;
}

function show_help_bin() {
	echo "Well-Formed ./bin/ directories in parent path"
	echo ""
	echo "When 'qq' is invoked it searches parent directories for a"
	echo "directory called './bin' that also contains a 'README.txt'"
	echo "and assumes that the commands in there are sufficiently well-"
	echo "formed to be callable as 'commmand --help' without side-effects."
	echo ""
	echo "...a dangerous assumption, but necessary to aid in discovery of"
	echo "those commands and increase the quality and documentation of"
	echo "said commands."
	echo ""
	echo "The first line of ./bin/README.txt should contain a useful"
	echo "description of the commands contained in that directory and"
	echo "may contain as much documentation as desired."
	echo ""
	echo "Subdirectories in the ./bin directory which also contain a"
	echo "./README.txt in the same format will be added as further"
	echo "junction points for more commands."
	echo ""
	echo "Example:"
	echo "  $ find ../bin -type f"
	echo "  ../bin/README.txt"
	echo "  ../bin/foo"
	echo "  ../bin/bar"
	echo "  ../bin/more/README.txt"
	echo "  ../bin/more/baz"
	echo "  $ qq"
	echo "  Commands from a bin dir"
	echo "    foo - info from ../bin/foo --help | head -1"
	echo "    bar - info from ../bin/bar --help | head -1"
	echo "    more - from head -1 ../bin/more/README.txt"
	echo "  $ qq more"
	echo "  Commands from ../bin/more/README.txt directory"
	echo "    baz - info from ../bin/more/baz --help | head -1"
	exit;
}

function parent_dirs {
	pushd . > /dev/null
	ALL_PARENT_DIRS="$( pwd ) "
	PWD=$( pwd )
	IX=50
	while [[ "$PWD" != "/" && $IX > 0 ]] ; do
		cd ..
		PWD=$( pwd )
		ALL_PARENT_DIRS=$( printf "$ALL_PARENT_DIRS\n$PWD" )
		IX=$(( $IX - 1 ))
	done
	echo "$ALL_PARENT_DIRS"
	popd > /dev/null
}

# given a list of directories, filter down to only those which contain
# './bin/README*'s
function descend_points_bin {
	CANDIDATE_DIRS=$1
	echo "$CANDIDATE_DIRS" | while read cur_dir ; do
		if [ -f $cur_dir/bin/README.txt ] ; then
			echo $cur_dir/bin
		fi
	done
}

# from within a ./bin/README.txt, any subdirs which also contain README.txt
# should be considered as sub-descend points based on directory name
function descend_points_sub {
	START_DIR=$1
	SUBDIRS=$( find $START_DIR -name README.txt -maxdepth 5 | sed 's/\/README.*//g' | sort )
	echo "$SUBDIRS"
}


function show_all_path {
	COMMANDS=$( compgen -c qq- )
	if [ "" != "$COMMANDS" ] ; then
		echo "$COMMANDS" | while read linker ; do
			LINKER_OUTPUT=$( $linker )
			DESC=$( echo "$LINKER_OUTPUT" | head -1 )
			LINKER_AS_DIR=$( echo $linker | sed 's/-/\//g' )
			echo D $LINKER_AS_DIR $DESC
			echo "$LINKER_OUTPUT" | sed "1d" | while read linker_line ; do
				TYPE_ONLY=$( echo $linker_line | awk '{ print $1 }' )
				CMD_ONLY=$( echo $linker_line | awk '{ $1=""; $2=""; print $0 }' )
				NAME_ONLY=$( echo $linker_line | awk '{ print $2 }' )
				echo $TYPE_ONLY $LINKER_AS_DIR/$NAME_ONLY $CMD_ONLY
			done
		done
	fi
}

function show_all_dir {
	DIR=$1
	PREFIX=$2
	if [ -f $DIR/README.txt ] ; then
		printf "D qq${PREFIX} "
		cat $DIR/README.txt | head -1
		SUBCOMMANDS=$( find $DIR -perm +111 -type f -maxdepth 1 | sed 's/^.*\///g' | sort )
		echo "$SUBCOMMANDS" | while read subcommand ; do
			echo X qq${PREFIX}/$subcommand $DIR/$subcommand
		done
	fi
}


function show_all {
	show_all_path
	PD=$( parent_dirs );
	DPB=$( descend_points_bin "$PD" );
	if [ "" != "$DPB" ] ; then
		echo "$DPB" | while read dir ; do
			DPS=$( descend_points_sub $dir )
			MASTER_DIR_LENGTH=$( echo $dir | wc -c )
			echo "$DPS" | while read subdir ; do
				PREFIX=$( echo $subdir | cut -c ${MASTER_DIR_LENGTH}- - )
				show_all_dir $subdir $PREFIX
			done
		done
	fi
}

ARGSARR=( "$@" )
ix=0

if [ "--help" == "$1" ] ; then
	show_help
	exit
fi
if [ "--help-path" == "$1" ] ; then
	show_help_path
	exit
fi
if [ "--help-bin" == "$1" ] ; then
	show_help_bin
	exit
fi
if [ "--all" == "$1" ] ; then
	show_all
	exit
fi


function descend_one_level {
	pushd . > /dev/null

	CUR_DIR=$1
	cd $CUR_DIR
	DESCRIPTION=$( head -1 ./README.txt )

	SUBCOMMANDS=$( find . -perm +111 -type f -maxdepth 1 | sed 's/^\.\///g' )
	echo "$DESCRIPTION"
	echo "$SUBCOMMANDS" | while read an_executable ; do
		SUB_DESCRIPTION=$( ./$an_executable --help | head -1 )
		echo "  $an_executable - $SUB_DESCRIPTION"
	done

	popd > /dev/null
}

function doc_for_point {
	ALL="$1"
	POINT=$2
	PADDING=$3
	POINT=$( echo $POINT | sed -e 's/[]\/$*.^|[]/\\&/g' )  # make safe for sed-replacement (!!)
	FOUND_LINE=$( echo "$ALL" | grep "^X $POINT " )
	if [ "$?" == "0" ] ; then
		EXECUTABLE=""
		CMD=$( echo $FOUND_LINE | awk -- '{print $3}' )
		DOC=$( $CMD --help | head -1 )
	else
		EXECUTABLE="*"
		PADDING=$(( $PADDING - 1 ))
		DOC=$( echo "$ALL" | awk -- "\$2 ~ /^$POINT$/ { found = 1; if (\$1 = \"D\"){ \$1 = \"\" ; \$2 = \"\" ; print \$0 } } END { if ( found == 0 ) { print \"...\" } }" )
	fi
	DOC=$( echo $DOC | sed 's/^ *//g' )
	printf "%s %${PADDING}s %s\n" "$EXECUTABLE" "-" "$DOC"
}

function one_level {
	COMMANDS=$1
	PREFIX=$2
	PREFIX=$( echo $PREFIX | sed -e 's/[]\/$*.^|[]/\\&/g' )  # make safe for sed-replacement (!!)
	FILTERED=$( echo "$COMMANDS" | awk -- "/^${PREFIX}\// { print \$0 }" )
	#                  remove prefix             # remove suffix     # uniq
	echo "$FILTERED" | sed "s/${PREFIX}\/\(.*\)$/\1/g" | sed "s/\/.*$//g"   |  uniq
}

function one_level_all_special {
	ALL=$1
	PREFIX=$2
	FILTERED=$( echo "$ALL" | awk -- "/^. ${PREFIX}\// { print \$2 } /^. qq / { \$1=\"\"; \$2=\"\"; print \"! \" \$0 }" )
    #                  remove prefix             # remove suffix     # uniq
	echo "$FILTERED" | sed "s/^${PREFIX}\/\(.*\)$/\1/g" | sed "s/\/.*$//g"   |  uniq
}

function deepest_completion_point {
	ALL="$1"
	shift
	COMMANDS=$( echo "$ALL" | awk -- '{print $2}' )
	POINT=qq
	COMMAND_FOUND=0   # reversed to behave like grep
	while [[ "$1" != "" && $COMMAND_FOUND == "0" ]] ; do
		CUR_LEVEL=$( one_level "$COMMANDS" $POINT )
		echo "$ALL" | grep "$POINT/$1" > /dev/null
		COMMAND_FOUND=$?
		if [ "0" == "$COMMAND_FOUND" ] ; then
			POINT="$POINT/$1"
			shift
		fi
	done

	echo $POINT
}

function delegate_if_exists {
	ALL="$1"
	CMD="$2"
	shift
	shift
	CMD=$( echo $CMD | sed -e 's/[]\/$*.^|[]/\\&/g' )  # make safe for sed-replacement (!!)
	EXISTS=$( echo "$ALL" | grep "^X" | awk -- "\$2 ~ /^$CMD$/ { print \$3 }" )
	if [ "" != "$EXISTS" ] ; then
		# damn!  need to consume a bunch of "$@"'s per each "qq-$CMD-$CMD"
		DASHES=$( echo $CMD | sed 's/[^/]//g' | wc -c )
		DASHES=$(( $DASHES - 1 ))  # remove newline character from count
		shift $DASHES
		exec $EXISTS "$@"
		exit "$?"
	fi
}

function document {
	ALL="$1"
	POINT="$2"

	if [ "" == "$ALL" ] ; then
		show_help
		exit
	fi


	if [ "qq" == "$POINT" ] ; then
		# top-level has special rules to intermingle top-level docs w/ command docs
		CUR_LEVEL=$( one_level_all_special "$ALL" $POINT )
	else
		COMMANDS=$( echo "$ALL" | awk -- '{print $2}' )
		CUR_LEVEL=$( one_level "$COMMANDS" $POINT )
	fi

	LONGEST_COMMAND=$( echo "$CUR_LEVEL" | grep -v '^!' | awk '{ if ( length > L ) { L=length } }END{ print L }' )
	echo "$CUR_LEVEL" | while read sub ; do
		# see if this line is special
		echo $sub | grep '^!' > /dev/null
		IS_SPECIAL="$?"
		if [ "0" == "$IS_SPECIAL" ] ; then
			echo "$sub" | sed 's/^\!\ *//g'
		else
			CMD_LENGTH=$( echo $sub | wc -c )
			PADDING=$(( $LONGEST_COMMAND - $CMD_LENGTH + 3 ))
			DOC=$( doc_for_point "$ALL" "${POINT}/${sub}" $PADDING )
			printf "  %s%s\n" "$sub" "$DOC"
		fi
	done
}

# see how deep we can recognize command nodes / sub-nodes
ALL=$( show_all )
DC=$( deepest_completion_point "$ALL" "$@" )
# this will exec and exit otherwise proceed directly to documentation
delegate_if_exists "$ALL" "$DC" "$@"
if [[ "$DC" == "qq" && "$1" != "" ]] ; then
	echo "Error: $1 not found!"
	exit 1
else
	printf "Commands for qq\n"
	document "$ALL" "$DC"
	exit 0
fi

